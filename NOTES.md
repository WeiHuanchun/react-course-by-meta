# NOTES

## `package.json` vs. `package-lock.json`

The [`package.json`](command:_github.copilot.openRelativePath?%5B%22package.json%22%5D 'package.json') and [`package-lock.json`](command:_github.copilot.openRelativePath?%5B%22package-lock.json%22%5D 'package-lock.json') files are both crucial in a Node.js project, but they serve different purposes:

-   [`package.json`](command:_github.copilot.openRelativePath?%5B%22package.json%22%5D 'package.json'): This file is used to store metadata about the project, such as its name, version, and description. It also lists the project's dependencies and their version ranges. The version ranges in [`package.json`](command:_github.copilot.openRelativePath?%5B%22package.json%22%5D 'package.json') allow for updates to dependencies within the specified range.

-   [`package-lock.json`](command:_github.copilot.openRelativePath?%5B%22package-lock.json%22%5D 'package-lock.json'): This file is automatically generated (or updated) by npm when you install a package. It provides a detailed description of the exact dependency tree that was installed. This means it includes the exact versions of all dependencies and sub-dependencies used in the project. This ensures that every install results in the exact same dependency tree, regardless of intermediate dependency updates.

You can find these files in your workspace at [`package.json`](command:_github.copilot.openRelativePath?%5B%22package.json%22%5D 'package.json') and [`package-lock.json`](command:_github.copilot.openRelativePath?%5B%22package-lock.json%22%5D 'package-lock.json').

## default export vs. name export

In JavaScript, there are two types of exports: default exports and named exports.

-   **Default exports**: Each module can have one default export. This is typically used when a module only exports one thing, like a class or function. You can import the default export without knowing its name, just referring to it as the default import. For example, in your `App.jsx` file, if you have a default export:

```javascript
// src/App.jsx
export default function App() {
    /* ... */
}
```

You can import it like this:

```javascript
// src/main.jsx
import App from './App.jsx';
```

-   **Named exports**: A module can have multiple named exports. This is useful for utility modules that export several functions. A named export must be imported with the exact same name. For example, if you have a named export in a utility file:

```javascript
// src/utils.js
export function utilityFunction() {
    /* ... */
}
```

You can import it like this:

```javascript
// src/main.jsx
import { utilityFunction } from './utils.js';
```

You can find examples of these in your workspace at [`src/App.jsx`](command:_github.copilot.openRelativePath?%5B%22src%2FApp.jsx%22%5D 'src/App.jsx') and [`src/main.jsx`](command:_github.copilot.openRelativePath?%5B%22src%2Fmain.jsx%22%5D 'src/main.jsx').

## props

-   JavaScript object
-   props
    -   pass data between components
    -   Arguments are passed like HTML attributes
    -   use the keyword props

## React props

-   send multiple data types
-   Flexible dynamic content

## Parent component

-   Pass data only one way: from parent to the children

```jsx
function Greeting(props) {
    return <h1>Hello, {props.name}</h1>;
}

// Usage
<Greeting name="Alice" />;
```

```jsx
function Greeting(parameters) {
    return <h1>Hello, {parameters.name}</h1>;
}

// Usage
<Greeting name="Alice" />;
```

## pure function

## Nav component

## JSX syntax

### JSX expressions

```jsx
let name = 'Alice';
let greeting = <h1>Hello, {name}!</h1>;
```

### JSX return statement

### <></>

### className

camel case , not same as CSS:`class`

```jsx
function Sidebar() {
    const asideStyle = {
        background: 'azure',
        width: 'calc(30%-10px)',
        marginLeft: '10px',
    };

    return (
        <aside style={asideStyle} className="sidebar-component">
            <h2>Sidebar content here</h2>
        </aside>
    );
}

export default Sidebar;
```

## Embedded Expressions

```jsx
// FmtName.jsx
import { formatName } from '../utils/FormatName.js';

function Name(name) {
    return <p>{formatName(name.firstName, name.lastName)}</p>;
}

export default Name;
```

```jsx
// App.jsx
import './App.css';
import Sidebar from './components/Sidebar';
import { formatName } from './utils/FormatName';
import Name from './components/FmtName';

function App() {
    return (
        <div className="App">
            <Sidebar />
            <p>{formatName('Jane', 'Wilson')}</p>
            <Name firstName="John" lastName="Doe" />
        </div>
    );
}

export default App;
```

## Expressions in HTML Attributes

```jsx
const url = 'photo.png';

const result = <img src={url}></img>;
```

## Embedded Expressions in HTML Attributes

```jsx
import avatar from './avatar.png';

function Logo(props)
    const userPic = <img src={avatar} />
    return userPic;

```

## Events

No need to learn all events, and they are not specific to React. And some of events are used in specific cases, such as in limited `drag api`.

Sure, here's a simple table comparing event names in HTML and JSX:

| HTML Event Name | JSX Event Name |
| --------------- | -------------- |
| onclick         | onClick        |
| onsubmit        | onSubmit       |
| onfocus         | onFocus        |
| onblur          | onBlur         |
| onkeydown       | onKeyDown      |
| onkeypress      | onKeyPress     |
| onkeyup         | onKeyUp        |
| onload          | onLoad         |
| onscroll        | onScroll       |
| onmouseenter    | onMouseEnter   |
| onmouseleave    | onMouseLeave   |
| onmouseover     | onMouseOver    |
| onmouseout      | onMouseOut     |
| onmousedown     | onMouseDown    |
| onmouseup       | onMouseUp      |
| ontouchstart    | onTouchStart   |
| ontouchend      | onTouchEnd     |
| ontouchmove     | onTouchMove    |
| onchange        | onChange       |
| oninput         | onInput        |
| oninvalid       | onInvalid      |
| onselect        | onSelect       |

Please note that in JSX, event names are written in camelCase, while in HTML they are all lowercase.

In JSX, you can use all standard JavaScript events because it's just JavaScript. However, there are some synthetic events provided by React that are not available in standard HTML. Here's a table of some of these:

| JSX Event Name       |
| -------------------- |
| onCopy               |
| onCut                |
| onPaste              |
| onCompositionEnd     |
| onCompositionStart   |
| onCompositionUpdate  |
| onDrag               |
| onDragEnd            |
| onDragEnter          |
| onDragExit           |
| onDragLeave          |
| onDragOver           |
| onDragStart          |
| onDrop               |
| onAnimationStart     |
| onAnimationEnd       |
| onAnimationIteration |
| onTransitionEnd      |

These events are part of the SyntheticEvent system in React, which is a cross-browser wrapper around the browserâ€™s native event system.

### Common event handling

```jsx
function Btn() {
    const clickHandler = () => {
        console.log('Button clicked!');
    };
    return <button onClick={clickHandler}>Click Me</button>;
}
```

| Event            | Event Handler | Action        |
| ---------------- | ------------- | ------------- |
| (Click a button) | (onClick)     | (Open a menu) |

## Data Flow

Single direction: from parent to child.

## Hooks

### `{useState}`

1. Creates a state variable with an initial value
2. Create a function to set that state variable's value

### Build your own hooks

## What is state

-   Stateful component
    ```jsx
    const [word, setWord] = React.useState('Hello');
    // accomplished by ES6 array destructuring
    ```
-   Stateless component
    > doesn't change data, all data inherits from props.

## Sibling components

### Prop drilling

From parent to its child

### Global state

-   React context api

    1. No need for prop drilling
    2. No need for lifting state up

    ```jsx
    // MealsProvider.jsx
    import React from 'react';

    const MealsContext = React.createContext();

    const todaysMeals = [
        'Baked Chicken',
        'Steamed Broccoli',
        'Rice',
        'Apple Pie',
    ];

    const MealsProvider = ({ children }) => {
        const [meals, setMealsList] = React.useState(todaysMeals);
        return (
            <MealsContext.Provider value={{ meals }}>
                {children}
            </MealsContext.Provider>
        );
    };

    export const useMealsContext = () => React.useContext(MealsContext);

    export default MealsProvider;
    ```

    > The double curly braces in this context are doing two different things:
    >
    > 1.  The outer curly braces `{}` are used to embed a JavaScript expression in JSX. This is a common pattern in React and is how you can include dynamic content in your JSX.
    >
    > 2.  The inner curly braces `{}` are creating a new JavaScript object. In this case, the object has one property `meals` which is shorthand for `meals: meals`. This is using the ES6 object property shorthand syntax, where if your object's key and variable name are the same, you can write it once instead of `meals: meals`.
    >
    > So, `{ {meals} }` is passing an object `{meals: meals}` as a prop to `MealsContext.Provider`. The value of `meals` is coming from the state or props of the parent component.
    >
    > This is a common pattern when using React's Context API, where you often want to pass down an object so that you can include multiple values or functions in the context.

    ```jsx
    // MealList
    import { useMealsContext } from '../context/MealsProvider';

    const MealList = () => {
        const { meals } = useMealsContext();

        return (
            <div>
                <h1>Meals List using Context API</h1>
                {meals &&
                    Array.isArray(meals) &&
                    meals.map((meal, index) => <h2 key={index}>{meal}</h2>)}
            </div>
        );
    };
    export default MealList;
    ```

    ```jsx
    // App.jsx
    import './App.css';
    import Sidebar from './components/Sidebar';
    import { formatName } from './utils/FormatName';
    import Name from './components/FmtName';
    import Btn from './components/Btn';
    import Handling from './components/Handling';
    import ThemeContext from './context/ThemeContext';
    import HelloWorld from './components/Helloworld';
    import { useState } from 'react';
    import MealsProvider from './context/MealsProvider';
    import MealList from './components/MealsList';
    import Counter from './components/Counter';
    import ReducerExample from './components/ReducerExample';

    function App() {
        const initialTheme = {
            color: 'red',
            backgroundColor: 'blue',
        };
        const [theme, setTheme] = useState(initialTheme);

        return (
            <div className="App">
                <Sidebar />
                <p>{formatName('Jane', 'Wilson')}</p>
                <Name firstName="John" lastName="Doe" />
                <Btn />
                <Handling />
                <ThemeContext.Provider value={{ theme, setTheme }}>
                    <HelloWorld />
                </ThemeContext.Provider>
                <MealsProvider>
                    <MealList />
                    <Counter />
                </MealsProvider>
                <ReducerExample />
            </div>
        );
    }

    export default App;
    ```

    [It provides the ability to pass a information from the parent component to all its children to any nested level without passing the information through props in each level.](https://www.tutorialspoint.com/reactjs/reactjs_using_usecontext.htm)

-   Extract state and Import state

### Reducer hook

```jsx
// ReducerExample.jsx
import { useReducer } from 'react';

const reducer = (state, action) => {
    if (action.type === 'ride') return { money: state.money + 10 };
    if (action.type === 'fuel') return { money: state.money - 20 };
    return new Error('No action type found');
};

function ReducerExample() {
    const initialState = { money: 100 };

    const [state, dispatch] = useReducer(reducer, initialState);

    return (
        <div>
            <h1>Reducer Example</h1>
            <p>Money: {state.money}</p>
            <button onClick={() => dispatch({ type: 'ride' })}>Ride</button>
            <button onClick={() => dispatch({ type: 'fuel' })}>Fuel</button>
        </div>
    );
}

export default ReducerExample;
```

```jsx
// App.jsx
import './App.css';
import Sidebar from './components/Sidebar';
import { formatName } from './utils/FormatName';
import Name from './components/FmtName';
import Btn from './components/Btn';
import Handling from './components/Handling';
import ThemeContext from './context/ThemeContext';
import HelloWorld from './components/Helloworld';
import { useState } from 'react';
import MealsProvider from './context/MealsProvider';
import MealList from './components/MealsList';
import Counter from './components/Counter';
import ReducerExample from './components/ReducerExample';

function App() {
    const initialTheme = {
        color: 'red',
        backgroundColor: 'blue',
    };
    const [theme, setTheme] = useState(initialTheme);

    return (
        <div className="App">
            <Sidebar />
            <p>{formatName('Jane', 'Wilson')}</p>
            <Name firstName="John" lastName="Doe" />
            <Btn />
            <Handling />
            <ThemeContext.Provider value={{ theme, setTheme }}>
                <HelloWorld />
            </ThemeContext.Provider>
            <MealsProvider>
                <MealList />
                <Counter />
            </MealsProvider>
            <ReducerExample />
        </div>
    );
}

export default App;
```

## Recall

-   Props and State
    1. **Props data (Stateless) is imutable, State data (Stateful) is mutable**
    2. Stateless component Doesn't store data and change data, All data must inherits from parent
        > Used when State not need to work
    3. Stateful component used When state must be maintained to work.
    4. a prop doesn't always have to pass a state
       ![a prop doesn't always have to pass a state](public/DataToChildComponent.png)
-   Hooks
    1. `useState`
    2. `useContext`
    3. `useReducer`

## Website Navigation

Browse through various pages or links from a single component

### The navbar

```jsx
import './App.css';
import FooterComponent from './components/FooterComponent';
import HeaderComponent from './components/HeaderComponent';
import ListUserComponent from './components/ListUserComponent';
import { BrowserRouter, Route, Routes } from 'react-router-dom';
import UserComponent from './components/UserComponent';

function App() {
    return (
        <BrowserRouter>
            <HeaderComponent />
            <Routes>
                {/* http://localhost:3000/user/find */}
                <Route path="/" element={<ListUserComponent />} />
                {/* http://localhost:3000/user/add-user */}
                <Route path="/add-user" element={<UserComponent />} />
                {/* http://localhost:3000/user/update-user */}
                <Route path="/update-user/:id" element={<UserComponent />} />
            </Routes>
            <FooterComponent />
        </BrowserRouter>
    );
}

export default App;
```

### Conditional renderring

### assets

-   `src/assets` folder or `public` folder
    1. In `public` folder, no component import it
    2. In `src/assets` folder, there are components import it

### Using embedded assets

-   import images from `src/assets`
-   React Player (A Third-Party Library)
-   Choose a Third-party libraries
    1. frequency of updates
    2. Github page
    3. Internet search

## functional component vs. arrow functional component

### function vs. arrow function

In JavaScript, you can define functions using the `function` keyword or as arrow functions. Here are the main differences:

1. **Syntax**: Arrow functions have a shorter syntax compared to function declarations.

```javascript
// Function declaration
function add(a, b) {
    return a + b;
}

// Arrow function
const add = (a, b) => a + b;
```

2. **`this` keyword**: In a function declaration, `this` is defined by the caller of the function. In an arrow function, `this` is lexically bound, meaning it's set to the value of `this` in the surrounding code where the arrow function is defined.

```javascript
// Function declaration
const obj1 = {
    value: 'abc',
    createFunction: function () {
        return function () {
            console.log(this.value);
        };
    },
};
obj1.createFunction()(); // undefined

// Arrow function
const obj2 = {
    value: 'abc',
    createFunction: function () {
        return () => {
            console.log(this.value);
        };
    },
};
obj2.createFunction()(); // 'abc'
```

3. **Arguments object**: Function declarations have access to the `arguments` object, a local variable available within all non-arrow functions. Arrow functions do not have their own `arguments` object. Instead, they inherit from the parent scope.

```javascript
// Function declaration
function myFunction() {
    console.log(arguments[0]);
}
myFunction('hello', 'world'); // 'hello'

// Arrow function
const myArrowFunction = () => {
    console.log(arguments[0]);
};
myArrowFunction('hello', 'world'); // ReferenceError: arguments is not defined
```

4. **Constructors**: Function declarations can be used as constructors (with the `new` keyword), but arrow functions cannot.

```javascript
// Function declaration
function Person(name) {
    this.name = name;
}
const john = new Person('John'); // Works fine

// Arrow function
const Animal = (name) => {
    this.name = name;
};
const dog = new Animal('Dog'); // TypeError: Animal is not a constructor
```

5. **Method definitions**: If you're defining a method in an object literal or class, you might want to use a method definition instead of an arrow function to make sure `this` behaves as expected.

```javascript
const obj = {
    value: 'abc',
    myMethod() {
        console.log(this.value);
    },
};
obj.myMethod(); // 'abc'
```

### function compnent vs. arrow function component

In React, you can define components using either function declarations or arrow functions. Here's an example of each:

```jsx
// Function declaration
function Greeting1({ name }) {
    return <h1>Hello, {name}!</h1>;
}

// Arrow function
const Greeting2 = ({ name }) => <h1>Hello, {name}!</h1>;
```

Both of these components are equivalent and will behave the same way. The choice between function declarations and arrow functions is mostly a matter of style and preference.

However, there are a few differences to be aware of:

1. **`this` keyword**: In a function component, `this` is undefined because React calls function components as plain functions, not as methods. In an arrow function, `this` would be the surrounding (lexical) context, but since arrow function components are also called as plain functions, `this` is also undefined. So in practice, `this` is not used in function components.

2. **Hoisting**: Function declarations are hoisted, which means they are lifted to the top of their scope. This allows you to use the function before it's defined. Arrow functions are not hoisted, so you need to define an arrow function before you use it.

3. **Naming**: Function declarations are named, meaning the function name appears in stack traces, which can be helpful for debugging. Arrow functions are anonymous, so they might not appear with a useful name in stack traces. However, if you assign an arrow function to a variable (like `const Greeting2` above), that variable name will appear in stack traces.

In general, either style can be used to define React components, and the choice between them is largely a matter of preference.

### `useRef`

```jsx
// Calculator.jsx
import { useRef, useState } from 'react';

const Calculator = () => {
    const inputRef = useRef(null);
    const resultRef = useRef(null);

    const [result, setResult] = useState(0);

    const plus = (e) => {
        e.preventDefault();
        setResult((result) => result + Number(inputRef.current.value));
    };

    const minus = (e) => {
        e.preventDefault();
        setResult((result) => result - Number(inputRef.current.value));
    };

    const times = (e) => {
        e.preventDefault();
        setResult((result) => result * Number(inputRef.current.value));
    };

    const divide = (e) => {
        e.preventDefault();
        setResult((result) => result / Number(inputRef.current.value));
    };

    const resetInput = (e) => {
        e.preventDefault();
        inputRef.current.value = 0;
    };

    const resetResult = (e) => {
        e.preventDefault();
        setResult(0);
    };

    return (
        <div>
            <div>
                <h1>Calculator</h1>
            </div>
            <h2 ref={resultRef}>{result}</h2>
            <form>
                <input type="number" ref={inputRef} />
                <br />
                <button onClick={plus}>+</button>
                <button onClick={minus}>-</button>
                <button onClick={times}>*</button>
                <button onClick={divide}>/</button>
                <button onClick={resetInput}>Reset Input</button>
                <button onClick={resetResult}>Reset Result</button>
            </form>
        </div>
    );
};

export default Calculator;
```

#### When to use `useRef`

`useRef` is a built-in React Hook that is commonly used for the following purposes:

1. **Accessing DOM Elements**: If you need to directly interact with a DOM element, you can use `useRef` to get a reference to it. This is useful for reading values that are not part of React's state (like the current value of an input field), or for invoking imperative DOM APIs (like focusing an input field).

```jsx
const inputRef = useRef(null);

// In a callback or effect:
inputRef.current.focus();
```

2. **Storing Mutable Variables**: `useRef` can also be used to store mutable variables that persist across re-renders but do not cause the component to re-render when they change. This can be useful for tracking the previous state or props, storing timeouts or intervals, or storing other mutable values.

```jsx
const intervalRef = useRef();

useEffect(() => {
    intervalRef.current = setInterval(() => {
        console.log('Hello, world!');
    }, 1000);

    return () => {
        clearInterval(intervalRef.current);
    };
}, []);
```

Remember that `useRef` does not cause a re-render when its value changes, unlike `useState` or `useEffect`. So it's not suitable for storing state that affects the component's output. For that, you should use `useState` or `useContext`.
